<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Perizia Veicolo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* CSS INVARIATO - OMESSO PER BREVITÀ */
        /* ... (tutto il CSS precedente) ... */
        #preloader .loading-text {
            color: #00aeff;
            animation: textGlow 1.8s infinite alternate ease-in-out;
            text-align: center; 
            width: 100%; 
        }
    </style>
</head>
<body>
    <script>
    // Variabili globali (esistenti)
    // ... (tutte le variabili globali esistenti) ...
    const CAPTURED_PHOTOS_KEY = `${APP_PREFIX}capturedPhotos_LS_LEGACY`; // Rinominiamo per evitare conflitti se si lasciano vecchi dati LS
    const DB_NAME = "perizieFotoDB";
    const DB_VERSION = 1;
    const PHOTO_STORE_NAME = "fotoStore";
    let db; // Variabile globale per l'istanza del database IndexedDB

    // NUOVE Variabili per il contesto della galleria (già introdotte)
    let currentGalleryTargaFilter = null;
    let currentGallerySectionFilter = null; 
    let lastViewBeforeGallery = 'landing';
    let lastSectionBeforeGallery = null;


    // MODIFICA: Versione App aggiornata
    const currentAppVersion = "1.4.0"; 
    const latestChangesText = `
        <li>Modificata la cattura foto in JPEG per ridurre dimensioni e migliorata gestione errori galleria.</li>
        <li>Galleria ora filtrabile per targa e sezione.</li>
        <li>Header completo (con selettore targa e navigazione sezioni) visibile in galleria se aperta da una perizia.</li>
        <li>Testo "Caricamento elenco targhe..." centrato.</li>
        <li>Tempo anteprima foto dopo scatto ridotto a 1 secondo.</li>
        <li>Introdotta gestione base di IndexedDB per archiviazione foto (per supportare >50 foto).</li>
    `;

    // --- INIZIO SEZIONE CODICE INDEXEDDB ---

    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(PHOTO_STORE_NAME)) {
                    const store = db.createObjectStore(PHOTO_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    store.createIndex('timestamp_idx', 'timestamp', { unique: false });
                    store.createIndex('targa_idx', 'targa', { unique: false });
                    store.createIndex('section_idx', 'section', { unique: false });
                    // Potrebbe essere utile un indice composto [targa, section]
                    // store.createIndex('targa_section_idx', ['targa', 'section'], { unique: false });
                    console.log("Object store 'fotoStore' creato con indici.");
                }
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log("Database IndexedDB aperto con successo.");
                resolve(db);
            };

            request.onerror = (event) => {
                console.error("Errore apertura IndexedDB:", event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    function addPhotoToDB(photoData) { // photoData include { name, timestamp, targa, section, imageBlob }
        return new Promise((resolve, reject) => {
            if (!db) {
                console.error("Database non inizializzato per addPhotoToDB.");
                return reject("DB not initialized");
            }
            const transaction = db.transaction([PHOTO_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(PHOTO_STORE_NAME);
            
            // Controllo limite (opzionale con IndexedDB, ma 500 è un target)
            const countRequest = store.count();
            countRequest.onsuccess = () => {
                if (countRequest.result >= 700) { // Limite un po' più alto per sicurezza
                    console.warn("Limite foto in DB raggiunto, tentativo di rimozione della più vecchia.");
                    // Implementa la rimozione della foto più vecchia se necessario
                    // Questo richiede un cursore ordinato per timestamp in senso ascendente
                    let oldestPhotoCursor = store.index('timestamp_idx').openCursor(null, 'next'); // 'next' per il più vecchio
                    let deleteOldestRequest;
                    oldestPhotoCursor.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                           deleteOldestRequest = store.delete(cursor.primaryKey);
                           deleteOldestRequest.onsuccess = () => {
                               console.log("Foto più vecchia rimossa per fare spazio.");
                               actuallyAdd();
                           }
                           deleteOldestRequest.onerror = (e) => reject("Errore rimozione foto vecchia: " + e.target.error);
                        } else {
                           actuallyAdd(); // Nessuna foto da eliminare, o errore apertura cursore vecchio.
                        }
                    }
                    oldestPhotoCursor.onerror = (e) => reject("Errore apertura cursore foto vecchia: " + e.target.error);

                } else {
                    actuallyAdd();
                }
            }
            countRequest.onerror = (e) => {
                console.error("Errore conteggio foto in DB:", e.target.error);
                actuallyAdd(); // Prova ad aggiungere comunque se il conteggio fallisce
            }

            function actuallyAdd() {
                const request = store.add(photoData);
                request.onsuccess = () => resolve(request.result); // Ritorna l'ID della foto aggiunta
                request.onerror = (event) => {
                    console.error("Errore aggiunta foto a IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            }

            transaction.oncomplete = () => console.log("Transazione aggiunta foto completata.");
            transaction.onerror = (event) => console.error("Errore transazione aggiunta foto:", event.target.error);
        });
    }

    function getPhotosFromDB(targaFilter, sectionKeyFilter) {
        return new Promise((resolve, reject) => {
            if (!db) {
                 console.error("Database non inizializzato per getPhotosFromDB.");
                 return reject("DB not initialized");
            }
            const transaction = db.transaction([PHOTO_STORE_NAME], 'readonly');
            const store = transaction.objectStore(PHOTO_STORE_NAME);
            const photos = [];

            let request;
            if (targaFilter) {
                const targaUpper = targaFilter.toUpperCase();
                const targaIndex = store.index('targa_idx');
                request = targaIndex.openCursor(IDBKeyRange.only(targaUpper));
            } else { // Galleria globale
                request = store.openCursor(null, 'prev'); // 'prev' per ordinare per ID decrescente (più recenti prima, se ID è autoinc)
                                                          // o usare timestamp_idx in 'prev'
            }
            
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const photo = cursor.value;
                    let includePhoto = true;

                    if (targaFilter) { // Già filtrato dall'index, ma doppia verifica non fa male
                        if (photo.targa.toUpperCase() !== targaFilter.toUpperCase()) {
                            includePhoto = false;
                        }
                    }

                    if (includePhoto && targaFilter && sectionKeyFilter && sectionKeyFilter !== 'riepilogo') {
                        let filterMatchKey = sectionKeyFilter.toLowerCase();
                        if (filterMatchKey === 'danniverifiche') filterMatchKey = 'danni';
                        if (photo.section.toLowerCase() !== filterMatchKey) {
                            includePhoto = false;
                        }
                    }
                    // Se sectionKeyFilter è 'riepilogo' o null (con targaFilter), tutte le foto della targa sono incluse.
                    // Se targaFilter è null (globale), tutte le foto sono incluse.

                    if (includePhoto) {
                        photos.push(photo);
                    }
                    cursor.continue();
                } else {
                    // Fine del cursore, ordina per timestamp se non già fatto dall'index
                    if (!targaFilter) { // Se globale, l'ordine da ID autoincrement potrebbe essere sufficiente se inserite in ordine
                         photos.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    } else if (targaFilter) { // Se filtrate per targa, ordina per timestamp
                        photos.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    }
                    resolve(photos);
                }
            };
            request.onerror = (event) => {
                console.error("Errore recupero foto da IndexedDB:", event.target.error);
                reject(event.target.error);
            };
        });
    }

    function deletePhotoFromDB(photoId) { // photoId è la chiave primaria dell'oggetto store
        return new Promise((resolve, reject) => {
            if (!db) {
                 console.error("Database non inizializzato per deletePhotoFromDB.");
                 return reject("DB not initialized");
            }
            const transaction = db.transaction([PHOTO_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(PHOTO_STORE_NAME);
            const request = store.delete(photoId);

            request.onsuccess = () => resolve();
            request.onerror = (event) => {
                console.error("Errore eliminazione foto da IndexedDB:", event.target.error);
                reject(event.target.error);
            };
        });
    }

    // --- FINE SEZIONE CODICE INDEXEDDB ---

    // ... (tutte le funzioni esistenti: updateTargaDetailsDisplay, populateTargaSwitcherDropdown, etc. ) ...
    
    function capturePhoto() {
        if (captureBtn.disabled) return; 

        if (currentCameraStream && cameraStreamElement.readyState >= cameraStreamElement.HAVE_CURRENT_DATA && cameraStreamElement.videoWidth > 0) {
            const canvas = document.createElement('canvas');
            canvas.width = cameraStreamElement.videoWidth; 
            canvas.height = cameraStreamElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(cameraStreamElement, 0, 0, canvas.width, canvas.height);
            
            freezeFrameDisplayElement.src = canvas.toDataURL('image/jpeg', 0.7); // Per anteprima immediata
            freezeFrameDisplayElement.style.display = 'block';
            cameraStreamElement.style.display = 'none'; 
            captureBtn.disabled = true; 

            canvas.toBlob(async (blob) => {
                if (!blob) {
                    console.error("Errore: canvas.toBlob() ha restituito null.");
                    alert("Errore nella creazione del file immagine.");
                    freezeFrameDisplayElement.style.display = 'none';
                    cameraStreamElement.style.display = 'block';
                    captureBtn.disabled = false;
                    return;
                }

                const targaForFile = (targaSelezionataGlobalmente || currentGalleryTargaFilter || 'SCONOSCIUTA').toUpperCase().replace(/[^A-Z0-9]/g, '');
                const sectionNameForFile = getFilenameSectionName();

                const counterKey = `${APP_PREFIX}photoCount_${targaForFile}_${sectionNameForFile}`;
                let photoNumber = parseInt(localStorage.getItem(counterKey) || '0') + 1; // Contatore ancora su LS per semplicità
                localStorage.setItem(counterKey, photoNumber.toString());
                
                const formattedPhotoNumber = String(photoNumber).padStart(3, '0');
                const filename = `${formattedPhotoNumber} ${sectionNameForFile} ${targaForFile}.jpeg`; 
                
                // Download link
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob); // Usa blob per download
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href); // Pulisci object URL del download
                console.log(`Foto "${filename}" scaricata.`);

                const photoDataForDB = {
                    name: filename,
                    timestamp: new Date().toISOString(),
                    targa: targaForFile,
                    section: sectionNameForFile, // La sezione logica/categoria
                    imageBlob: blob
                };

                try {
                    await addPhotoToDB(photoDataForDB);
                    console.log(`Foto "${filename}" salvata in IndexedDB.`);
                } catch (e) {
                    console.error("Errore salvataggio foto in IndexedDB:", e);
                    alert("Errore durante il salvataggio della foto nel database interno. La foto è stata scaricata.");
                }

                setTimeout(() => {
                    freezeFrameDisplayElement.style.display = 'none';
                    freezeFrameDisplayElement.src = '#'; 
                    cameraStreamElement.style.display = 'block';
                    captureBtn.disabled = false; 
                }, 1000); // Tempo anteprima: 1 secondo

            }, 'image/jpeg', 0.7);

        } else {
            console.warn("Stream fotocamera non pronto o dimensioni video non disponibili per la cattura.");
        }
    }

    async function populatePhotoGrid(targaFilter, sectionKeyFilter) { // MODIFICATA PER INDEXEDDB
        photoGridContainer.innerHTML = ''; 
        
        // Pulisci vecchi Object URL se ce ne sono (gestione più robusta sarebbe necessaria)
        photoGridContainer.querySelectorAll('img[src^="blob:"]').forEach(img => URL.revokeObjectURL(img.src));

        let photosToDisplay = [];
        try {
            photosToDisplay = await getPhotosFromDB(targaFilter, sectionKeyFilter);
        } catch (e) {
            console.error("Errore nel caricare le foto da IndexedDB:", e);
            photoGridContainer.innerHTML = '<p>Errore nel caricare le foto dal database.</p>';
            return;
        }

        if (photosToDisplay.length === 0) {
            photoGridContainer.innerHTML = '<p>Nessuna foto trovata per i filtri applicati.</p>';
            return;
        }

        // L'ordinamento per timestamp dovrebbe essere già gestito da getPhotosFromDB o fatto lì
        // photosToDisplay.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp)); 

        photosToDisplay.forEach((photoData) => {
            const photoItemDiv = document.createElement('div');
            photoItemDiv.classList.add('photo-item');
            const img = document.createElement('img');
            
            if (photoData.imageBlob) {
                img.src = URL.createObjectURL(photoData.imageBlob);
                // Considera di revocare img.src con img.onload se l'immagine viene sostituita o rimossa,
                // o quando la vista della galleria viene nascosta/distrutta.
                // img.onload = () => { /* URL.revokeObjectURL(img.src); // Se non serve più per questa istanza */ };
            } else {
                img.alt = "Dati immagine non disponibili";
            }
            img.alt = photoData.name;
            
            const caption = document.createElement('div');
            caption.classList.add('photo-item-caption');
            caption.textContent = photoData.name;
            
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('photo-item-delete-btn');
            deleteBtn.innerHTML = '&times;'; 
            deleteBtn.title = "Elimina foto";
            deleteBtn.addEventListener('click', async (e) => {
                e.stopPropagation(); 
                if (confirm("Sei sicuro di voler eliminare questa foto dal database dell'app?")) {
                    try {
                        await deletePhotoFromDB(photoData.id); // Usa l'ID primario da IndexedDB
                        console.log("Foto eliminata da DB con ID:", photoData.id);
                        // Ripopola la griglia con i filtri correnti
                        populatePhotoGrid(currentGalleryTargaFilter, currentGallerySectionFilter); 
                    } catch (err) {
                        console.error("Errore eliminazione foto da DB:", err);
                        alert("Errore durante l'eliminazione della foto dal database.");
                    }
                }
            });
            photoItemDiv.appendChild(img);
            photoItemDiv.appendChild(caption);
            photoItemDiv.appendChild(deleteBtn);
            photoGridContainer.appendChild(photoItemDiv);
        });
    }
    
    // deleteCapturedPhoto non è più necessaria nel vecchio formato,
    // l'eliminazione avviene tramite deletePhotoFromDB e il refresh di populatePhotoGrid.

    // Modifica showGalleryPage per gestire la pulizia degli Object URL quando la galleria non è più la vista attiva.
    // Potrebbe essere fatto in showView o quando si cambia targa/sezione.
    // Per ora, la pulizia è solo all'inizio di populatePhotoGrid, che non è ideale per foto che restano visibili.

    // ... (Altre funzioni esistenti come showView, handleTargaSelectionAndSync, etc. RESTANO INVARIATE NELLA LORO LOGICA DI BASE,
    // ma populatePhotoGrid ora è asincrona, quindi se showGalleryPage la chiama,
    // showGalleryPage o le sue parti che dipendono dal completamento di populatePhotoGrid potrebbero necessitare di 'await' o gestione promesse)

    // Assicurati di inizializzare il DB all'avvio dell'app
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            await initDB(); // Inizializza IndexedDB
        } catch (e) {
            console.error("Inizializzazione IndexedDB fallita:", e);
            alert("Impossibile inizializzare il database delle foto. La galleria potrebbe non funzionare correttamente.");
        }

        // ... (resto del codice in DOMContentLoaded, incluso l'aggancio degli event listener)
        // NOTA: Il codice precedente per `latestChangesText` e `currentAppVersion` è stato spostato sopra.
        // Gli event listener per headerPhotosBtn, targaSwitcherDropdown, navButtons (quelli che interagiscono con la galleria)
        // dovrebbero continuare a funzionare come previsto, chiamando showGalleryPage che a sua volta chiama la nuova populatePhotoGrid.

        syncToSheetsBtn = document.createElement('button');
        syncToSheetsBtn.id = 'syncToSheetsBtn';
        syncToSheetsBtn.classList.add('action-button');
        syncToSheetsBtn.textContent = 'Sincronizza'; 
        syncToSheetsBtn.style.backgroundColor = '#ffc107'; 
        syncToSheetsBtn.style.borderColor = '#e0a800';
        syncToSheetsBtn.style.color = '#212529';
        const historyButton = document.getElementById('historyBtn'); 
        if (historyButton && historyButton.parentNode === utilityNavButtons) {
            utilityNavButtons.insertBefore(syncToSheetsBtn, historyButton.nextSibling);
        } else if (mainExitAppBtn && mainExitAppBtn.parentNode === utilityNavButtons) { 
             utilityNavButtons.insertBefore(syncToSheetsBtn, mainExitAppBtn); 
        } else if (utilityNavButtons.firstChild) {
            utilityNavButtons.insertBefore(syncToSheetsBtn, utilityNavButtons.firstChild);
        } else {
            utilityNavButtons.appendChild(syncToSheetsBtn);
        }
        syncToSheetsBtn.addEventListener('click', syncAllLocalDataToSheets);
        
        document.querySelectorAll('.fill-defaults-btn').forEach(button => {
            button.addEventListener('click', function() { 
                const sectionId = this.dataset.sectionid; 
                const sectionTarget = sectionId.replace('Section', ''); 
                if (sectionId) {
                    fillSectionPositiveOrDefaults(sectionId); 
                    if (saveProgress(targaSelezionataGlobalmente)) {
                        let currentSectionIndex = -1;
                        navButtons.forEach((nb, index) => { 
                            if (nb.dataset.target === sectionTarget) currentSectionIndex = index;
                        });
                        if (currentSectionIndex !== -1 && currentSectionIndex < navButtons.length - 1) { 
                            const nextNavButton = navButtons[currentSectionIndex + 1];
                            if (nextNavButton && nextNavButton.dataset.target) showSection(nextNavButton.dataset.target);
                        }
                    }
                }
            });
        });
        if (tipoTrazioneSelect) tipoTrazioneSelect.addEventListener('change', handleTrazioneChange);
        
        targaSwitcherDropdown.addEventListener('change', async function() {
            const nuovaTargaSelezionata = this.value;
            if (nuovaTargaSelezionata && nuovaTargaSelezionata.toUpperCase() !== (targaSelezionataGlobalmente ? targaSelezionataGlobalmente.toUpperCase() : null)) {
                this.disabled = true;
                if (galleryPageSection.style.display === 'block') {
                    targaSelezionataGlobalmente = nuovaTargaSelezionata.toUpperCase(); 
                    showGalleryPage(targaSelezionataGlobalmente, currentGallerySectionFilter); 
                } else {
                    let currentActiveSectionId = 'remarketing'; 
                    const activeSectionElement = document.querySelector('#checklistContainer .category-section.active');
                    if (activeSectionElement && activeSectionElement.id) {
                        currentActiveSectionId = activeSectionElement.id.replace('Section', '');
                    }
                    await handleTargaSelectionAndSync(nuovaTargaSelezionata, currentActiveSectionId);
                }
                this.disabled = false;
            } else if (nuovaTargaSelezionata) {
                updateTargaDetailsDisplay(nuovaTargaSelezionata);
            }
        });

        if(backToListBtn) backToListBtn.addEventListener('click', () => showView('landing'));
        if(historyBtn) historyBtn.addEventListener('click', () => showView('history'));
        if(clearAllProgressBtn) clearAllProgressBtn.addEventListener('click', clearAllSavedData);
        
        if(backToMainFromGalleryBtn) {
             backToMainFromGalleryBtn.addEventListener('click', () => {
                console.log(`Ritorno da galleria a: vista='${lastViewBeforeGallery}', sezione='${lastSectionBeforeGallery}'`);
                if (lastViewBeforeGallery === 'checklist' && currentGalleryTargaFilter && lastSectionBeforeGallery) {
                    if (targaSelezionataGlobalmente !== currentGalleryTargaFilter) {
                         targaSelezionataGlobalmente = currentGalleryTargaFilter;
                         loadProgress(targaSelezionataGlobalmente); 
                    }
                    showView('checklist');
                    showSection(lastSectionBeforeGallery);
                } else {
                    showView('landing'); 
                }
            });
        }

        if(saveAndReturnBtn) saveAndReturnBtn.addEventListener('click', handleSavePeriziaAndReturn);
        saveAndNextButtons.forEach(button=>button.addEventListener('click',handleSaveAndNext));

        if (headerExitBtn) {
            headerExitBtn.addEventListener('click', () => {
                console.log("Header Exit button clicked");
                triggerMainExit(); 
            });
        }

        if (headerPhotosBtn) { 
            headerPhotosBtn.addEventListener('click', () => {
                console.log("Header Photos/Gallery button clicked");
                let targaForGallery = null;
                let sectionKeyForGallery = null; 

                if (checklistContainer.style.display === 'block' && targaSelezionataGlobalmente) {
                    targaForGallery = targaSelezionataGlobalmente;
                    const activeSectionElement = document.querySelector('#checklistContainer .category-section.active');
                    if (activeSectionElement) {
                        sectionKeyForGallery = activeSectionElement.id.replace('Section', ''); 
                    }
                } 
                if (cameraPageSection.style.display === 'flex') { 
                    returnFromCamera(); 
                     setTimeout(() => showGalleryPage(targaForGallery, sectionKeyForGallery), 50); 
                } else {
                    showGalleryPage(targaForGallery, sectionKeyForGallery);
                }
            });
        }

        if (headerPeriziaBtn) {
            headerPeriziaBtn.addEventListener('click', async () => {
                console.log("Header Perizia button clicked");
                if (cameraPageSection.style.display === 'flex') { 
                    returnFromCamera(); 
                } else if (galleryPageSection.style.display === 'block') { 
                    if (currentGalleryTargaFilter && lastViewBeforeGallery === 'checklist' && lastSectionBeforeGallery) {
                        if (targaSelezionataGlobalmente !== currentGalleryTargaFilter) {
                            targaSelezionataGlobalmente = currentGalleryTargaFilter;
                            loadProgress(targaSelezionataGlobalmente);
                        }
                        showView('checklist');
                        showSection(lastSectionBeforeGallery);
                    } else { 
                        showView('landing');
                    }
                } else if (targaSelezionataGlobalmente) { 
                    const lastActivePage = localStorage.getItem(LAST_ACTIVE_PERIZIA_PAGE_KEY);
                    const targetSection = (lastActivePage && document.getElementById(lastActivePage + 'Section')) ? lastActivePage : 'riepilogo';
                    if (checklistContainer.style.display !== 'block' || targaSwitcherDropdown.value.toUpperCase() !== targaSelezionataGlobalmente.toUpperCase()) {
                        await handleTargaSelectionAndSync(targaSelezionataGlobalmente, targetSection);
                    } else {
                        showSection(targetSection);
                    }
                } else { 
                    showView('landing');
                }
            });
        }
        
        if (headerCameraBtn) {
            headerCameraBtn.addEventListener('click', () => {
                console.log("Header Camera button clicked");
                if (cameraPageSection.style.display === 'flex') {
                    returnFromCamera(); 
                } else {
                    showCameraPage(); 
                }
            });
        }

        if (captureBtn) captureBtn.addEventListener('click', capturePhoto);
        if (closeCameraBtn) closeCameraBtn.addEventListener('click', returnFromCamera); 

        navButtons.forEach(b => b.addEventListener('click', function() {
            const targetId = this.dataset.target;
            if (galleryPageSection.style.display === 'block' && currentGalleryTargaFilter) {
                currentGallerySectionFilter = targetId; 
                showGalleryPage(currentGalleryTargaFilter, currentGallerySectionFilter); 
            } else if (checklistContainer.style.display === 'block' || (!targaSelezionataGlobalmente && landingPageSection.style.display === 'block')) {
                showSection(targetId);
            } else if (!currentGalleryTargaFilter && galleryPageSection.style.display === 'block') {
                 console.log("Click su nav button da galleria globale, azione non definita o vai a landing.");
            }
        }));

        if (checklistContainer) {
            checklistContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
            checklistContainer.addEventListener('touchend', handleTouchEnd, { passive: true });
        }
        
        initializeApplicationViewAndLoadData(); 
        
        if (mainExitAppBtn) { 
            mainExitAppBtn.addEventListener('click', () => { 
                const exitCurtain = document.getElementById('exit-curtain'); 
                const mainContentWrapper = document.getElementById('mainContentWrapper'); 
                const pageHeader = document.getElementById('pageHeaderContainer'); 
                if (exitCurtain) { 
                    if (mainContentWrapper) mainContentWrapper.style.display = 'none'; 
                    if (pageHeader) pageHeader.style.display = 'none'; 
                    if (cameraPageSection) cameraPageSection.style.display = 'none'; 
                    if (currentCameraStream) { 
                         currentCameraStream.getTracks().forEach(track => track.stop());
                         currentCameraStream = null;
                         if(cameraStreamElement) cameraStreamElement.srcObject = null;
                    }
                    document.body.style.paddingTop = '0px'; 
                    const exitLoadingText = exitCurtain.querySelector('.loading-text'); 
                    const barContainer = exitCurtain.querySelector('.loader-bar-container'); 
                    const defaultCloseText = "CHIUSURA IN CORSO..."; 
                    const glitchText = "ERRORE DI SISTEMA..."; 
                    exitCurtain.classList.remove('glitching', 'flash-out-effect');  
                    if (exitLoadingText) { exitLoadingText.textContent = defaultCloseText; exitLoadingText.style.animation = 'textGlow 1.8s infinite alternate ease-in-out'; exitLoadingText.style.color = '#ff8787'; exitLoadingText.style.textShadow = ''; } 
                    exitCurtain.setAttribute('data-text', defaultCloseText); 
                    if (barContainer) barContainer.style.display = 'flex'; 
                    exitCurtain.classList.add('visible-no-transition'); 
                    exitCurtain.style.display = 'flex';  
                    setTimeout(() => { 
                        exitCurtain.classList.add('glitching'); 
                        if (exitLoadingText) { exitLoadingText.textContent = glitchText; exitLoadingText.style.animation = '';  } 
                        exitCurtain.setAttribute('data-text', glitchText); 
                        setTimeout(() => { 
                            exitCurtain.classList.remove('glitching'); 
                            if (exitLoadingText) { exitLoadingText.textContent = 'Applicazione terminata.'; exitLoadingText.style.animation = 'none';  exitLoadingText.style.color = '#FFFFFF';  exitLoadingText.style.textShadow = 'none'; } 
                            if (barContainer) barContainer.style.display = 'none';  
                            setTimeout(() => { 
                                exitCurtain.classList.add('flash-out-effect');  
                                setTimeout(() => { 
                                    const macrodroidUrl = 'https://trigger.macrodroid.com/5759064d-6af9-4af0-aef0-2548335e41fd/chiudi'; 
                                    fetch(macrodroidUrl, { method: 'GET', mode: 'no-cors' })  
                                    .then(response => console.log('Macrodroid trigger request sent.')) 
                                    .catch(error => console.error('Error sending Macrodroid trigger:', error)); 
                                }, 500);  
                            }, 700);  
                        }, 800);  
                    }, 800);  
                } 
            }); 
        }
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</body>
</html>
